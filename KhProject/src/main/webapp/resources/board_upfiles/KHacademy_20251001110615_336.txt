// * Method : 하나의 기능 단위
 * 스트림의 주요 중간 연산
 * 
1. filter() : 조건에 맞는 요소만 필터링
2. map() : 요소를 반환할 때 사용하는 연산
3. distinct() : 요소의 중복을 제거할 때  
스트림의 주요 최종 연산

1. collect() : 결과를 컬렉션으로 변환
2. forEach() : 모든 요소에 대한 작업 수행
3. count() : 요소 개수 반환
4. reduce() : 요소를 결합해서 단일 결과 만들어낼때
 * 
 */
// 스트림(Stream)
// 컬렉션, 배열 등의 데이터를 선언적으로 처리해주는 API
// for문 -> 어떻게 반복하는지가 구체적
// 함수형 -> 무엇을 할지 행위에 집중
// 파이프라이닝 -> 여러 연산을 연결

변수 : Memory(RAM)에 값을 저장하기 위한 공간

/*
 * 변수를 사용했더니?
 * 
 * 1. 단 한번 값을 대입해서 필요한 순간마다 다시 사용할 수 있음
 * 	=> 재사용성이 높아짐
 * 2. 값에 의미를 부여할 수 있음
 * 	=> 가독성이 높아짐
 * 
 * 가독성과 재사용성이 높아지면 유지보수가 용이해짐
 */
Type Casting(자료형 변환) : 자료형을 바꾸는 개념
* 
 *  ★☆★☆★☆★☆★☆ 매우 중요 ★☆★☆★☆★☆★☆★☆★
 * 
 * 우리가 과정 끝날때 까지 까먹으면 큰일나는!!!
 * 자바에서 값을 처리하는 규칙
 * 
 * 1. =(대입 연산자)를 기준으로 왼쪽/ 오른쪽 같은 자료형이어야 함.
 *	=> 같은 자료형에 해당하는 리터럴값만 대입할 수 있음
 *	=>자료형이 다를 경우 ? == 값을 바꿔서 대입해야 함.
 *
 *  2. 같은 자료형들끼리 연산이 가능함
 *  => 자료형이 다른데 연산이 하고싶다?? 둘 중 하나를 "형변환"해서 나머지 하나의 동일하게 맞춤
 *  
 *  3. 연산의 결과물도 동일한 자료형이어야 한다.
 *   => 1 + 1 = 2(정수), 1.1 + 1.1(실수)

형 변환의 종류 (2가지)
1. 사용중변환(promotion) : 사용으로 형변환이 진행됨
2. 강제형변환(Type Casting : 자동형변환이 이루어지지 않는 경우 진행

자동형변환(Promotion) : 작은 자료형 -> 큰 자료형

강제 형 반환 : 큰 크기의 자료형 -> 작은 크기의 자료형 (명시적 형변환)

배열(Array) : 하나의 배열에 여러 개의 값을 담을 수 있음 단, " 같은 자료형의 값들"만 담을 수 있음 동종
모음(homogeneous collection)이라고도 함
자바라는 언어 자체에 내장된 유일한 자료구조 
=> 배열의 각 인덱스에 실제 값이 담김. index는 '0'부터 시작한다.
 배열은 물리적인구조와 논리적인 구조가 동일합니다.

참조자료형은 주소값을 담는 공간이다.

객체 지향 프로그래밍 : 현실세계에서의 독립적인 존재(개체)를 속성과 행위를 가지도록 만들어서
객체라는 상호작용을 통해 프로그래밍 하는 기법

클래스란? 각 객체들의 정보(속성, 행위)들을 담아내는 그릇 또는 틀 또는 설계도 또는 명세
캡슐화 (encapsulation)
속성(데이터)과 해당 데이터를 조작하는 행동(메소드)를 하나의 단위로 묶는 것
정보은닉(information hiding)

static : 공유의 목적
fianl : 한번 초기화하고 죽었다 깨나도 안바꾸겠다.

생성자(Constuctor) : 객체를 생성하는데 사용하는 특수한 유형의 메소드 
생성자의 역할
기술적인 관점 : 객체가 생성될 때 어떤 상태로 시작을 해야하는가
개념적인 관점 : 객체가 처음부터 유효한 상태를 가지도록 강제


메소드 오버로딩(Method Overloading) ☆★☆★ => 면접 단골 질문
 하나의 클래스 안에 동일한 메소드 식별자로 여러 개의 메소드들을 정의할 수 있는 기술!
 매개변수 자료형의 개수, 순서, 종류 다르게 작성해야함!
 참고로 매개변수 식별자, 접근제한자, 반환타입은 메소드 오버로딩에 아무런 영향을 끼치지 않음!

정적 바인딩(static Binding)
컴파일이 끝난 시점 어떤 메소드가 호출될지 결정
컴파일러가 알아서 코드를 분석하여 메소드 호출

상속이란 
기존 클래스의 멤버(변수, 메서드 등)를 재활용하여 새로운 클래스를 만드는 자바의 문법

<오버라이딩>
오버라이딩은 상위 클래스의 메소드를 하위 클래스에서 재정의하는 것으로
메소드 이름, 매개변수, 반환 타입이 모두 동일해야 합니다.

클래스 형 변환
상속 구조"일 경우에만 가능

1. Up Casting 자식 타입 => 부모 타입 생략이 가능함

 2. Down Casting 부모 타입 => 자식 타입 생략이 불가능함.

동적바인딩 : 프로그램 "샐행 전" 컴파일 시점에 정적바인딩 수행(자료의 메소드를 가리킴)
실질적으로 참조하고 있는 객체가 해당 메소드를 오버라이딩 했다면
프로그램 "실행 시점" 동적으로 자식클래스의 오버라이딩된 메소드를 실행
(Runtime)

다형성 : 부모클래스 자료형으로 여러 자식클래스를 다루는 기술

추상클래스 
자식들이 오버라이딩 해서 다형성을 적용시켜 사용할 용도의 메소드

checkedException 
문법적으로 반드시 예외처리를 해야하는 예외들
=> 주로 외부 매체 입/출력 시
UncheckedException
프로그램 실행 시 발생하는 예외들 RuntimeException

3. String클래스의 hashCode()
주소값을 해싱하는 것이 아니라 실제 담긴 문자열값을 기반으로 해시코드 값을 만들도록 오버라이딩

Wrapper Class
=> 기본 자료형을 참조자료형으로 포장해주는 클래스들을 래퍼클래스라고함

 파싱(parsing) == 특정 데이터를 규칙에 따라서 분석하고 해석하는 과정

제너릭 <Generic>

 컬렉션을 사용하면서 다를 타입들을 미리 지정할 수 있는 기능 => 명시적으로<Integer>, <Plant>
별도의 제너릭 없이 컬렉션 객체 생성 ( E == Object )
장점 : 
 1. 다른 요소들의 타입을 제한할 수 있음 => 실수를 줄일 수 있음 
2. 매 번 형변환하는 절차를 없앨 수 있음 => 코드 짤 때 편함

배열과 컬렉션의 차이점

배열의 아주 쬐금 불편한 점
		 * 
1. 배열을 사용하려고 할 떄 꼭 크기를 할당을 해야함 => 한 번 지정된 크기는 변경이 불가능
2. 배열 중간 위치에 새로운 요소를 추가하거나 삭제할 때 기존값을 밀어주거나 땡기는 코드를 써야함

- 컬렉션
1. 크기의 제약이 없음
=> 처음 컬렉션을 사용할 때 크기를 지정하지 않더라도 사용할 수 있음
=> 만약 요소가 추가되면서 크기를 넘어서는 상황이 발생하면 알아서 확장이 된다.
2. 중간에 값을 추가하거나 삭제하는 경우 기존값을 밀어주거나 땡겨주는 로직이 이미 구현되어 있음
=> 그때그때 필요한 메소드들을 호출해서 사용하면 됨

-- 중립
 - 배열의 경우 하나의 타입의 자료형만 사용할 수 있음
- 컬렉션의 경우 여러 타입의 데이터들을 관리할 수 있음 : 같은 타입의 데이터만 묶어서도 사용가능

사용할 데이터의 개수가 명확히 정해져있고, 조화의 목적 => 배열
데이터들의 추가, 수정, 삭제가 많이 일어난다 => 컬렉션
 
* 추상 클래스
 * 인터페이스
 * 
 * - 인터페이스의 필드는 상수 필드
 * 
 * - 인터페이스의 메소드 키워드를 붙이지 않는 이상 추상메소드
 * 
 * - 인터페이스는 다중 구현을 허용한다.
 * 
 * - 무조건 구현해야하는 기능이 있을 경우 인터페이스를 사용해서
 * 		사용법만 만들어주고 구현하는 쪽에서 실체화하게 만듬" ==> 오버라이딩
 * 
 *  1. 추상클래스와 인터페이스의 공통점 
 *  
 * - 객체 생성은 불가능하지만, 부모자료형의 참조타입으로는 사용 가능함(다형성을 적용할 수 있음)
 * - 추상메소드를 가지고 있을 경우, 상속(구현)받는 클래스에서 추상메소드를 오버라이딩 하도록 강제함
 * 
 *  2. 차이점
 *  
 *  - 추상클래스 : 멤버로 일반필드, 일반메소드를 가질 수 있음
 *  			추상메소드는 있어도 그만 없어도 그만
 *  
 *  - 인터페이스 : 상수 필드, 특정한 경우르 제외하면 모든 메소드를 추상메소드로 정의 해야함
 *  
 *  둘 다 다형성을 적용하여 외부에서 보여지는 타입의 용도로 사용하지만
 *  -> 추상클래스는 자식클래스가 상속을 받아도 필드 / 메소드를 재사용하고 클래스를 확장하는 용도
 *  
 *  -> 인터페이스는 기능의 구현을 강제하기 위한 용도
 * 
동적바인딩과 정적바인딩
동적바인딩은 객체의 실제타입에 따라 메서드가 실행되는것을 의미한다.
정적바인딩은 이미 메서드의 실행타입을 알고있는 경우를 의미한다.
정적바인딩은 메소드이름이 같아도 매개변수가 달라 원하는 메소드를 호출할수있다.




기본 자료형
자바라는 언어에 자체적으로 내장되어있는 자료형

참조 자료형
클래스가 하나의 자료형이 될 수 있음
크기가 개발자 마음대로
실제 값은 heap에 올라감
주소 값(4Byte)만 변수에 저장

--------------------------------------------------

강제 형변환

부모타입 -> 자식타입
큰자료형 -> 작은자료형

-------------------------------------------------
오버라이딩
단일 클래스는 안됨,  두 개 이상이어야함
두 개의 클래스가 상속 구조일때
부모 클래스에서 물려받은 메소드 자식클래스에서 덮어씌울 때
메소드 명 같고, 매개변수 같고, 반환형 같아야 함
호출 시 오버라이딩된 메서드가 호출됨

오버로딩
하나의 클래스가 전제조건
하나의 클래스안에 같은 이름의 메소드를 여러개 만들 수있음
매개변수의 형태가 달라야함 
public 이름 같음(int a)
public 이름 같음(string b) 
이렇게

------------------------------------------------
동적 바인딩
오버라이딩의 대표적인 예
호출할 때 자식 메소드가 호출됨

정적바인딩
오버로딩의 대표적인예
메소드 이름이 같아도 매개변수가 달라
원하는 메소드를 호출할 수 있다.

---------------------------------------------------

자바에서 자료구조를 담당하는 프레임워크로 추가,정렬, 삭제등의 여러 기능을 구현하여 제공함
 => Collection

다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에서 컴파일 시점에 타입을 검사하는 기능으로
사용 시 타입 체크와 형변환(다운캐스팅)을 생략할 수 있음
=> Generic

기본자료형 데이터를 객체 형태로 변경할 수 있도록 감싸는 역할을 하는 클래스
=> Wrapper

-------------------------------------------------------
바이트 기반 스트림	문자기반 스트림
~~~Stream으로 끝남	Reader
~~InputStream		Writer
~~OutputStream

-파일을 읽기위한 바이트 기반 스트림
=>파일을 읽기 위한것이기 때문에 FileInputStream

- 객체를 출력하기위한 바이트기반 스트림
 => ObjectOutputStream

- 버퍼를 이용하여 효율적으로 읽기위한 문자기반 스트림
BufferReader

HashSet에 저장되는 객체의중복검사를 위해서
(a)equals 와 (b)hashset 메소드를 오버라이딩한다
(a) hashset => 객체에 저장된 값이 같은지 비교
(b) close() => 객체의 식별번호를 반환하는메서드
(c) Object => 최상위 클래스

-------------------------------------------------------

Checked Exceptioin
try~catch로 잡아줘야함 IOException 같이 위험하다고 경고를 해줌

Unchecked Exception
실행해보기전까지 알 수 없음
체크를 안해줌
스스로 생각하고 판단해서
예외처리를 해줘야함
try~catch같은걸로

